#!/usr/bin/env bash

# gah! Get App Homie!
#
# @author Marek `marverix` SierociÅ„ski
# @license GNU GPLv3

# Pipeline mode
set -e

#--------------------------------------------------
#region Constants

VERSION="0.1.2"
HELP_STRING="Type 'gah help' to show help."

#endregion
#--------------------------------------------------
#region Variables

tmp_dir=""

#endregion
#--------------------------------------------------
#region Utils

function print_blue() {
	echo -e "\033[0;34m$1\033[0m"
}

function print_green() {
	echo -e "\033[0;32m$1\033[0m"
}

function print_yellow() {
	echo -e "\033[0;33m$1\033[0m"
}

function throw_error() {
	echo -e "\033[0;31mError: $2\033[0m" >&2
	exit $1
}

function print_debug() {
	if [[ "$DEBUG" == "true" ]]; then
		echo -e "[DEBUG] $1" >&2
	fi
}

function cleanup() {
	if [[ -n "$tmp_dir" && -d "$tmp_dir" ]]; then
		rm -fr "$tmp_dir"
	fi
}

#endregion
#--------------------------------------------------
#region RegExp functions

EXT_ZIP="\.zip"
EXT_TAR="\.tar\.gz|\.tar\.xz|\.tar\.bz2"
EXT_ALL_ARCHIVES="$EXT_ZIP|$EXT_TAR"

REGEXP_EXT_ZIP=".+(${EXT_ZIP})$"
REGEXP_EXT_TAR=".+(${EXT_TAR})$"

function get_os() {
	print_debug "Checking OS type"
	case $(uname -s) in
		Linux*) echo "linux" ;;
		Darwin*) echo "macos" ;;
		*) echo "NOT_SUPPORTED" ;;
	esac
}

function get_os_regexp_part() {
	case $(get_os) in
		linux) echo '[_-](unknown[_-])?(linux|linux-gnu|linux-musl)' ;;
		macos) echo '[_-](apple[_-])?(darwin|macos)' ;;
		*) throw_error 10 "Your OS type is not supported" ;;
	esac
}

function get_arch() {
	print_debug "Checking CPU architecture"
	case $(uname -m) in
		x86_64|amd64) echo "amd64" ;;
		arm64|aarch64|armv8) echo "arm64" ;;
		*) echo "NOT_SUPPORTED" ;;
	esac
}

function get_arch_regexp_part() {
	case $(get_arch) in
		amd64) echo '[_-](amd64|x86_64)' ;;
		arm64) echo '[_-](arm64|aarch64)' ;;
		*) throw_error 11 "Your CPU/OS architecture is not supported" ;;
	esac
}

function get_filename_regexp() {
	local name_regexp_part='[a-z][a-z0-9-]+?'
	local version_regexp_part='([_-]v?[0-9]+\.[0-9]+\.[0-9]+)?'
	local os_regexp_part=$(get_os_regexp_part)
	local arch_regexp_part=$(get_arch_regexp_part)

	local regexp="${name_regexp_part}${version_regexp_part}"
	regexp+="(${os_regexp_part}${arch_regexp_part}|${arch_regexp_part}${os_regexp_part})"	
	regexp+="(${EXT_ALL_ARCHIVES})?"
	echo "$regexp"
}

function get_name_regexp() {
	echo "^$(get_filename_regexp)\$"
}

function get_md_url_regexp() {
	echo "\(https:\/\/[a-z0-9.\/]+\/$(get_filename_regexp)\)"
}

#endregion
#--------------------------------------------------
#region GitHub API functions

function get_fetch_release_info_url() {
	local suffix="latest"
	if [[ -n "$2" && "$2" != "latest" ]]; then
		suffix="tags/$2"
	fi

	echo "https://api.github.com/repos/$1/releases/$suffix"
}

function fetch_release_info() {
	local url=$(get_fetch_release_info_url "$1" "$2")
	print_debug "Fetching release information from: $url"

	curl -s "$url" > release.json

	local err_status=$(jq -r '.status' release.json)
	print_debug "Error status: $err_status"

	if [[ "$err_status" != "null" ]]; then
		throw_error 13 "Couldn't fetch release information.\nResponse from GitHub API: [$err_status] $(jq -r '.message' release.json)"
	fi

	local release_name=$(jq -r '.name' release.json)
	print_green "Found release: $release_name"
}

function find_download_url() {
	local release_json="$1"

	# First try to find the matching file in the assets
	local regexp=$(get_name_regexp)
	local found="false"
	
	print_debug "Regexp: $regexp"

	for name in $(jq -r '.assets[].name' "$release_json"); do
		lower_name=$(echo "$name" | tr '[A-Z]' '[a-z]')
		if [[ "$lower_name" =~ $regexp ]]; then
			print_debug "  $name ... Match!"
			found="true"
			jq -r --arg name "$name" '.assets[] | select(.name == $name) | .browser_download_url' "$release_json"
		else
			print_debug "  $name ... Doesn't match"
		fi
	done

	# If asset matched, return
	if [[ "$found" == "true" ]]; then
		return
	fi

	# If no asset matched, try to find the download URL in the release body
	print_debug "No asset matched, trying to find download URL in the release body"

	regexp=$(get_md_url_regexp)
	print_debug "URL Regexp: $regexp"
	
	jq -r '.body' "$release_json" | while read -r line; do
		lower_line=$(echo "$line" | tr '[A-Z]' '[a-z]')
		if [[ "$lower_line" =~ $regexp ]]; then
			print_debug "  $line ... Match!"
			line="${BASH_REMATCH[0]}"
			line=${line:1}
			line=${line::-1}
			echo $line
		else
			print_debug "  $line ... Doesn't match"
		fi
	done
}

#endregion
#--------------------------------------------------
#region Known aliases

declare -A aliases
aliases[argocd]="argoproj/argo-cd"
aliases[bat]="sharkdp/bat"
aliases[btm]="clementtsang/bottom"
aliases[duf]="muesli/duf"
aliases[fd]="sharkdp/fd"
aliases[fzf]="junegunn/fzf"
aliases[genact]="svenstaro/genact"
aliases[gh]="cli/cli"
aliases[goss]="goss-org/goss"
aliases[gping]="orf/gping"
aliases[helm]="helm/helm"
aliases[jq]="jqlang/jq"
aliases[k9s]="derailed/k9s"
aliases[kops]="kubernetes/kops"
aliases[lazygit]="jesseduffield/lazygit"
aliases[rg]="BurntSushi/ripgrep"
aliases[terragrunt]="gruntwork-io/terragrunt"
aliases[tofu]="opentofu/opentofu"
aliases[trufflehog]="trufflesecurity/trufflehog"
aliases[yq]="mikefarah/yq"

function get_known_alias() {
	echo "${aliases[$1]}"
}

#endregion
#--------------------------------------------------
#region Command functions

function command_help() {
	echo "gah"
	echo "  install <github_owner/github_repo_name | known_alias> [<git_tag>]"
	echo "  show <aliases>"
	echo "  help"
	echo "  version"
	exit 0
}

function command_version() {
	echo "gah v$VERSION"
	exit 0
}

function command_install() {
	# Create temporary directory
	tmp_dir=$(mktemp -d)

	# Change to temporary directory
	cd $tmp_dir

	# Fetch the release information
	print_blue "Fetching release info for: $1 [$2]"
	fetch_release_info "$1" "$2"

	# Find the download URL
	local download_url=$(find_download_url "$tmp_dir/release.json")
	print_debug "Download URL:\n$download_url"

	# Check if several download URLs were found
	if [[ $(echo "$download_url" | wc -l) -gt 1 ]]; then
		print_yellow "Several download URLs were found which match your OS and arch. Please select one:"
		select url in $download_url; do
			download_url=$url
			break
		done

		if [[ -z "$download_url" ]]; then
			throw_error 14 "No download URL was selected"
		fi
	fi

	# Get a filename
	local filename=$(basename "$download_url")

	# Download the file
	print_blue "Downloading: $filename"
	curl -L --progress-bar -o "$filename" "$download_url"

	# Extract if needed
	if [[ "$filename" =~ $REGEXP_EXT_TAR ]]; then
		print_blue "Extracting: $filename"
		tar -xf "$filename"

	elif [[ "$filename" =~ $REGEXP_EXT_ZIP ]]; then
		print_blue "Extracting: $filename"
		unzip -q "$filename"

	else
		print_debug "Does not look like supported archive - no need to extract"
		chmod +x "$filename"
	fi

	for bin_file in $(find . -type f -executable); do
		local bin_name=$(basename "$bin_file")
		print_blue "Installing: $bin_name"

		print_yellow "Give a new name or keep '$bin_name'? (Leave empty to keep the same)"
		read -p "New name: " new_name
		if [[ -n "$new_name" ]]; then
			bin_name="$new_name"
		fi

		mv "$bin_file" "$HOME/.local/bin/$bin_name"
		print_green "Installed: $bin_name"
	done

	print_green "Done!"
}

function command_show_aliases() {
	echo "Known aliases:"
	for alias in "${!aliases[@]}"; do
		echo "  $alias -> ${aliases[$alias]}"
	done
}

#endregion
#--------------------------------------------------

function main() {
	if [[ -z "$1" || "$1" == "help" ]]; then
		command_help

	elif [[ "$1" == "version" ]]; then
		command_version

	elif [[ "$1" == "install" ]]; then
		if [[ -z "$2" ]]; then
			throw_error 1 "Please provide either repo in format 'owner/repo_name' or known alias.\n$HELP_STRING"

		elif [[ "$2" == *"/"* ]]; then
			if [[ "$2" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]]; then
				repo="$2"
			else
				throw_error 2 "Given string '$2' is not in format 'owner/repo_name'.\n$HELP_STRING"
			fi

		elif [[ -n "${aliases[$2]}" ]]; then
			repo="${aliases[$2]}"

		else
			throw_error 3 "Given string '$2' is not a known alias.\nTo see known aliases type 'gah show aliases'."
		fi

		tag="$3"
		if [[ -z "$3" ]]; then
			tag=latest
		fi

		command_install "$repo" "$tag"

	elif [[ "$1" == "show" ]]; then
		if [[ "$2" == "aliases" ]]; then
			command_show_aliases

		else
			throw_error 4 "Unknown subcommand.\n$HELP_STRING"
		fi

	else
		throw_error 5 "Unknown command '$command'.\n$HELP_STRING"
	fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	# The script is being executed directly
	trap cleanup EXIT ERR SIGINT SIGTERM
	main "$@"
fi
